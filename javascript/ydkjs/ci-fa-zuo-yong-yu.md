# 词法作用域

> 作用域共有两种主要的工作模型。第一种是最为普遍的，被大多数编程语言所采用的词法作用域。另外一种叫作动态作用域，仍有一些编程语言在使用\(比如 Bash 脚本、Perl 中的一些模式等\)。

## 2.1 词法阶段

大部分标准语言编译器的第一个工作阶段叫作词法化\(也叫单词化\)。词法化的过程会对源代码中的字符进行检查，如果是有状态的解析过程，还会赋予单词语义。这个概念是理解词法作用域及其名称来历的基础。

词法作用域就是定义在词法阶段的作用域。是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变\(除了欺骗词法作用域的情况\)。

### 查找

无论函数在**哪里**被调用，也无论它**如何**被调用，它的词法作用域都**只由**函数被声明时所处的位置决定。

词法作用域查找只会查找一级标识符，比如 a、b 和 c。如果代码中引用了 foo.bar.baz，词法作用域查找只会试图查找 foo 标识符，找到这个变量后，对象属性访问规则会分别接管对 bar 和 baz 属性的访问。

## 2.2 欺骗词法

JavaScript 中有两种机制来实现这个目的。欺骗词法作用域会导致性能下降。

### 2.2.1 eval

eval\(..\) 函数可以接受一个字符串为参数，可以在你写的代码中用程序生成代码并运行，就好像代码是写在那个位置的一样。

在严格模式的程序中，eval\(..\) 在运行时有其自己的词法作用域，其中的声明无法修改所在的作用域。

### 2.2.2 with

with 通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。

尽管 with 块可以将一个对象处理为词法作用域，但是这个块内部正常的 var 声明并不会被限制在这个块的作用域中，而是被添加到 with 所处的函数作用域中。with 声明实际上是根据你传递给它的对象凭空创建了一个全新的词法作用域。

### 2.2.3 性能

JavaScript 引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。

但如果引擎在代码中发现了 eval\(..\) 或 with，它只能简单地假设关于标识符位置的判断都是无效的，因为无法在词法分析阶段明确知道 eval\(..\) 会接收到什么代码，这些代码会 如何对作用域进行修改，也无法知道传递给 with 用来创建新词法作用域的对象的内容到底是什么。





