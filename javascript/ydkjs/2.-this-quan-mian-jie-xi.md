# 2. this 全面解析

## 2.1 调用位置

在理解 this 的绑定过程之前，首先要理解调用位置:调用位置就是函数在代码中被调用的 位置\(而不是声明的位置\)。某些编程模式可能会隐藏真正的调用位置。

最重要的是要**分析调用栈**\(就是为了到达当前执行位置所调用的所有函数\)。我们关心的调用位置就在当前正在执行的函数的**前**一个调用**中**。

## 2.2 绑定规则

### 2.2.1 默认绑定

最常用的函数调用类型:独立函数调用。

如果使用严格模式\(strict mode\)，那么全局对象将无法使用默认绑定，因此 this 会绑定 到 undefined。

### 2.2.2 隐式绑定

当函数引用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。

#### 隐式丢失

被隐式绑定的函数特定情况下会丢失绑定对象，应用默认绑定，把this绑定到全局对象或者undefined上。

参数传递就是一种隐式赋值，传入函数时也会被隐式赋值。回调函数丢失this绑定是非常常见的。

### 2.2.3 显式绑定

可以使用函数的 call\(..\) 和 apply\(..\) 方法。它们的第一个参数是一个对象，它们会把这个对象绑定到 this，接着在调用函数时指定这个 this。

如果你传入了一个原始值\(字符串类型、布尔类型或者数字类型\)来当作 this 的绑定对 象，这个原始值会被转换成它的对象形式\(也就是new String\(..\)、new Boolean\(..\)或者 new Number\(..\)\)。这通常被称为“装箱”。

可惜，显式绑定仍然无法解决我们之前提出的丢失绑定问题。

#### 1. 硬绑定

但是显式绑定的一个变种可以解决这个问题。

硬绑定的典型应用场景就是创建一个包裹函数，传入所有的参数并返回接收到的所有值。

另一种使用方法是创建一个可以重复使用的辅助函数。

```javascript
function bind(fn, obj) {
  return function() {
    return fn.apply(obj, arguments)
  }
}
```

ES5内置了`Function.prototype.bind`，bind会返回一个硬绑定的新函数，它会把参数设置为 this 的上下文并调用原始函数。

#### 2. API 调用的“上下文”

第三方库的许多函数，以及 JavaScript 语言和宿主环境中许多新的内置函数，都提供了一个可选的参数，通常被称为“上下文”\(context\)，其作用和 bind\(..\) 一样，确保你的回调 函数使用指定的 this。

### 2.2.4 new 绑定

JavaScript 有一个 new 操作符，使用方法看起来也和那些面向类的语言一样，绝大多数开发者都认为 JavaScript 中 new 的机制也和那些语言一样。然而，JavaScript 中 new 的机制实际上和面向类的语言完全不同。

在 JavaScript 中，构造函数只是一些使用 new 操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上，它们甚至都不能说是一种特殊的函数类型，它们只是被 new 操作符调用的普通函数而已。

实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”。使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。

1. 创建\(或者说构造\)一个全新的对象。
2. 这个新对象会被执行\[\[原型\]\]连接。
3. 这个新对象会绑定到函数调用的this。
4. 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。

## 2.3 优先级

之所以要在 new 中使用硬绑定函数，主要目的是预先设置函数的一些参数，这样在使用 new 进行初始化时就可以只传入其余的参数。bind\(..\) 的功能之一就是可以把除了第一个参数\(第一个参数用于绑定 this\)之外的其他参数都传给下层的函数\(这种技术称为“部分应用”，是“柯里化”的一种\)。

### 判断 this

1. 函数是否在new中调用\(new绑定\)?如果是的话this绑定的是新创建的对象。 `var bar = new foo()`
2. 函数是否通过call、apply\(显式绑定\)或者硬绑定调用?如果是的话，this绑定的是指定的对象。 `var bar = foo.call(obj2)`
3. 函数是否在某个上下文对象中调用\(隐式绑定\)?如果是的话，this 绑定的是那个上下文对象。 `var bar = obj1.foo()`
4. 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到全局对象。 `var bar = foo()`

## 2.4 绑定例外

### 2.4.1 被忽略的 this

如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值在调用时会被忽略，实际应用的是默认绑定规则。

一种非常常见的做法是使用 apply\(..\) 来“展开”一个数组，并当作参数传入一个函数。类似地，bind\(..\) 可以对参数进行柯里化\(预先设置一些参数\)。

在 ES6 中，可以用 ... 操作符代替 apply\(..\) 来“展 开”数组。可惜，在 ES6 中没有柯里化的相关语法，因此还是需要使用 bind\(..\)。

然而，总是使用 null 来忽略 this 绑定可能产生一些副作用。如果某个函数确实使用了 this\(比如第三方库中的一个函数\)，那默认绑定规则会把 this 绑定到全局对象\(在浏览 器中这个对象是 window\)，这将导致不可预计的后果\(比如修改全局对象\)。

#### 更安全的 this

一种“更安全”的做法是传入一个特殊的对象，把 this 绑定到这个对象不会对你的程序 产生任何副作用。

在 JavaScript 中创建一个空对象最简单的方法都是 Object.create\(null\)。Object.create\(null\) 和 {} 很像，但是并不会创建 Object.prototype 这个委托，所以它比 {}“更空”。

### 2.4.2 间接引用

间接引用最容易在赋值时发生:

```javascript
function foo() {
  console.log(this.a)
}
var a = 2
var o = { a: 3, foo }
var p = { a: 4 }
o.foo() // 3
(p.foo = o.foo)() // 2
```

赋值表达式 p.foo = o.foo 的返回值是目标函数的引用，因此调用位置是 foo\(\) 而不是 p.foo\(\) 或者 o.foo\(\)。这里会应用默认绑定。

注意:对于默认绑定来说，决定 this 绑定对象的并不是调用位置是否处于严格模式，而是函数体是否处于严格模式。如果函数体处于严格模式，this 会被绑定到 undefined，否则 this 会被绑定到全局对象。

### 2.4.3 软绑定

硬绑定这种方式可以把 this 强制绑定到指定的对象\(除了使用 new 时\)，防止函数调用应用默认绑定规则。问题在于，硬绑定会大大降低函数的灵活性，使 用硬绑定之后就无法使用隐式绑定或者显式绑定来修改 this。

如果可以给默认绑定指定一个全局对象和 undefined 以外的值，那就可以实现和硬绑定相同的效果，同时保留隐式绑定或者显式绑定修改 this 的能力。

## 2.5 this 词法

箭头函数不使用 this 的四种标准规则，而是根据外层\(函数或者全局\)作用域来决定 this。

## 2.6 小结

如果要判断一个运行中函数的 this 绑定，就需要找到这个函数的直接调用位置。找到之后

就可以顺序应用下面这四条规则来判断 this 的绑定对象。

1. 由new调用?绑定到新创建的对象。  
 2. 由call或者apply\(或者bind\)调用?绑定到指定的对象。  
 3. 由上下文对象调用?绑定到那个上下文对象。  
 4. 默认:在严格模式下绑定到undefined，否则绑定到全局对象。

ES6 中的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定 this，具体来说，箭头函数会继承外层函数调用的 this 绑定\(无论 this 绑定到什么\)。这 其实和 ES6 之前代码中的 self = this 机制一样。

