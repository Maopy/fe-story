# 2. this 全面解析

## 2.1 调用位置

在理解 this 的绑定过程之前，首先要理解调用位置:调用位置就是函数在代码中被调用的 位置\(而不是声明的位置\)。某些编程模式可能会隐藏真正的调用位置。

最重要的是要**分析调用栈**\(就是为了到达当前执行位置所调用的所有函数\)。我们关心的调用位置就在当前正在执行的函数的**前**一个调用**中**。

## 2.2 绑定规则

### 2.2.1 默认绑定

最常用的函数调用类型:独立函数调用。

如果使用严格模式\(strict mode\)，那么全局对象将无法使用默认绑定，因此 this 会绑定 到 undefined。

### 2.2.2 隐式绑定

当函数引用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。

#### 隐式丢失

被隐式绑定的函数特定情况下会丢失绑定对象，应用默认绑定，把this绑定到全局对象或者undefined上。

参数传递就是一种隐式赋值，传入函数时也会被隐式赋值。回调函数丢失this绑定是非常常见的。

### 2.2.3 显式绑定

可以使用函数的 call\(..\) 和 apply\(..\) 方法。它们的第一个参数是一个对象，它们会把这个对象绑定到 this，接着在调用函数时指定这个 this。

如果你传入了一个原始值\(字符串类型、布尔类型或者数字类型\)来当作 this 的绑定对 象，这个原始值会被转换成它的对象形式\(也就是new String\(..\)、new Boolean\(..\)或者 new Number\(..\)\)。这通常被称为“装箱”。

可惜，显式绑定仍然无法解决我们之前提出的丢失绑定问题。

#### 1. 硬绑定

但是显式绑定的一个变种可以解决这个问题。

硬绑定的典型应用场景就是创建一个包裹函数，传入所有的参数并返回接收到的所有值。

另一种使用方法是创建一个可以重复使用的辅助函数。

```javascript
function bind(fn, obj) {
  return function() {
    return fn.apply(obj, arguments)
  }
}
```

ES5内置了`Function.prototype.bind`，bind会返回一个硬绑定的新函数，它会把参数设置为 this 的上下文并调用原始函数。

#### 2. API 调用的“上下文”

第三方库的许多函数，以及 JavaScript 语言和宿主环境中许多新的内置函数，都提供了一个可选的参数，通常被称为“上下文”\(context\)，其作用和 bind\(..\) 一样，确保你的回调 函数使用指定的 this。

### 2.2.4 new 绑定

JavaScript 有一个 new 操作符，使用方法看起来也和那些面向类的语言一样，绝大多数开发者都认为 JavaScript 中 new 的机制也和那些语言一样。然而，JavaScript 中 new 的机制实际上和面向类的语言完全不同。

在 JavaScript 中，构造函数只是一些使用 new 操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上，它们甚至都不能说是一种特殊的函数类型，它们只是被 new 操作符调用的普通函数而已。

实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”。使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。

1. 创建\(或者说构造\)一个全新的对象。
2. 这个新对象会被执行\[\[原型\]\]连接。
3. 这个新对象会绑定到函数调用的this。
4. 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。

## 2.3 优先级

之所以要在 new 中使用硬绑定函数，主要目的是预先设置函数的一些参数，这样在使用 new 进行初始化时就可以只传入其余的参数。bind\(..\) 的功能之一就是可以把除了第一个参数\(第一个参数用于绑定 this\)之外的其他参数都传给下层的函数\(这种技术称为“部分应用”，是“柯里化”的一种\)。

### 判断 this

1. 函数是否在new中调用\(new绑定\)?如果是的话this绑定的是新创建的对象。 `var bar = new foo()`
2. 函数是否通过call、apply\(显式绑定\)或者硬绑定调用?如果是的话，this绑定的是指定的对象。 `var bar = foo.call(obj2)`
3. 函数是否在某个上下文对象中调用\(隐式绑定\)?如果是的话，this 绑定的是那个上下文对象。 `var bar = obj1.foo()`
4. 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到全局对象。 `var bar = foo()`



