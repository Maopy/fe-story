# 5. 作用域闭包

## 5.1 启示

需要付出非常多的努力和牺牲才能理解闭包这个概念。闭包是基于词法作用域书写代码时所产生的自然结果，你甚至不需要为了利用它们而有意识地创建闭包。

## 5.2 实质问题

**当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。**

无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用 域的引用，无论在何处执行这个函数都会使用闭包。

## 5.3 现在我懂了

本质上无论何时何地，如果将函数\(访问它们各自的词法作用域\)当作第一 级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、 Ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步\(或者同步\)任务中，只要使 用了回调函数，实际上就是在使用闭包!

## 5.4 循环和闭包

```javascript
for (var i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i)
  }, i * 1000)
}
```

这段代码在运行时会以每秒一次的频率输出五次 6。当然所有函数共享一个 i 的引用。循环结构让我们误以为背后还有更复杂的机制在起作用，但实际上没有。

缺陷：我们需要更多的闭包作用域，特别是在循环的过程中每个迭代都需要一个闭包作用域。

```javascript
for (var i=1; i<=5; i++) {
  (function(j) {
    setTimeout( function timer() {
      console.log( j );
    }, j*1000 );
  })( i );
}
```

### 重返块作用域

```javascript
for (let i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i)
  }, i * 1000)
}
```

## 5.5 模块

模块模式需要具备两个必要条件。一个具有函数属性的对象本身并不是真正的模块。

1. 必须有外部的封闭函数，该函数必须至少被调用一次\(每次调用都会创建一个新的模块实例\)。
2. 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。

使用IIFE，可以实现单例模式。

### 5.5.1 现代的模块机制

大多数模块依赖加载器 / 管理器本质上都是将这种模块定义封装进一个友好的 API。

```javascript
var MyModules = (function Manager() {
  var modules = {}
  
  function define(name, deps, impl) {
    for (var i = 0; i < deps.length; i++) {
      deps[i] = modules[deps[i]]
    }
    // 核心，为了模块的定义引入了包装函数(可以传入任何依赖)，并且将返回值，也就是模块的 API，储存在一个根据名字来管理的模块列表中。
    modules[name] = impl.apply(impl, deps)
  }
  
  function get(name) {
    return modules[name]
  }
  
  return {
    define: define,
    get: get
  }
})()
```

### 5.5.2 未来的模块机制

基于函数的模块并不是一个能被稳定识别的模式\(编译器无法识别\)，它们的 API 语义只有在运行时才会被考虑进来。因此可以在运行时修改一个模块的 API。

相比之下，ES6 模块 API 更加稳定\(API 不会在运行时改变\)。由于编辑器知道这一点，因此可以在\(的确也这样做了\)编译期检查对导入模块的 API 成 员的引用是否真实存在。如果 API 引用并不存在，编译器会在运行时抛出一 个或多个“早期”错误，而不会像往常一样在运行期采用动态的解决方案。

import 可以将一个模块中的一个或多个 API 导入到当前作用域中，并分别绑定在一个变量上。

module 会将整个模块的 API 导入并绑定到一个变量上。

export 会将当前模块的一个标识符\(变量、函数\)导出为公共 API。

