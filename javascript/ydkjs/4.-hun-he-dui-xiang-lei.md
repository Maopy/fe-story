# 4. 混合对象“类”

## 4.1 类理论

类 / 继承描述了一种代码的组织结构形式——一种在软件中对真实世界中问题领域的建模方法。

### 4.1.1 “类”设计模式

如果你有函数式编程\(比如 Monad\)的经验就会知道类也是非常常用的一种设计模式。

### 4.1.2 JavaScript 中的“类”

其他语言中的类和 JavaScript 中的“类”并不一样。

## 4.2 类的机制

### 4.2.1 建造

“类”和“实例”的概念来源于房屋建造。

### 4.2.2 构造函数

类实例是由一个特殊的类方法构造的，这个方法名通常和类名相同，被称为构造函数。这个方法的任务就是初始化实例需要的所有信息\(状态\)。

## 4.3 类的继承

定义好一个子类之后，相对于父类来说它就是一个独立并且完全不同的类。子类会包含父类行为的原始副本，但是也可以重写所有继承的行为甚至定义新行为。

### 4.3.1 多态

多态并不表示子类和父类有关联，子类得到的只是父类的一份副本。类的继承其实就是复制。

### 4.3.2 多重继承

JavaScript 要简单得多:它本身并不提供“多重继承”功能。

## 4.4 混入

JavaScript 开发者想出了一个方法来模拟类的复制行为，这个方法就是混入。

### 4.4.1 显示混入

这个功能在许多库和框架中被称为 extend\(..\)。

#### 1. 再说多态

JavaScript\(在 ES6 之前\)并没有相对多态的机制。为了指明调用对象，我们必须使用绝对\(而不是相对\)引用。因此，我们会使用 .call\(this\)。

使用伪多态通常会导致代码变得更加复杂、难以阅读并且难以维护，因此应当尽量避免使用显式伪多态，因为这样做往往得不偿失。

#### 2. 混合复制

遍历 sourceObj 的属性，如果在 targetObj 没有这个属性就会进行复制。

#### 3. 寄生继承

首先我们复制一份父类\(对象\)的定义，然后混入子类\(对象\)的定义\(如果需要的话保留到父类的特殊引用\)，然后用这个复合对象构建实例。

### 4.4.2 隐式混入

虽然这类技术利用了 this 的重新绑定功能，但是 Something.cool.call\( this \) 仍然无法变成相对\(而且更灵活的\)引用，所以使用时千万要小心。通常来说，尽量避免使用这样的结构，以保证代码的整洁和可维护性。

